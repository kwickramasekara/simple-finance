import { type ClassValue, clsx } from "clsx";
import { Models } from "node-appwrite";
import { twMerge } from "tailwind-merge";

/**
 * Returns a combined class name string from the provided class values.
 * Generated by ShadCN
 *
 * @param inputs - The class values to be combined.
 * @returns The combined class name string.
 */
export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

/**
 * Returns the month name for a given date.
 * @param date - The date in string format.
 * @param short - Optional parameter to return the short form of the month name.
 * @returns The month name as a string.
 */
export function getMonth(date: string, short = false): string {
  return new Date(date).toLocaleString("default", {
    month: short ? "short" : "long",
  });
}

/**
 * Formats a number as a currency string.
 *
 * @param value - The number to format as currency.
 * @param round - Whether to round the number or not. Default is true.
 * @param scale - Whether to scale the number for thousands and millions. Default is false.
 * @returns The formatted currency string.
 */
export function formatCurrency(
  value: number,
  round = true,
  scale = false
): string {
  // Determine the sign of the value (-1 for negative, 1 for positive, 0 for zero)
  const sign = Math.sign(value);

  // Use the absolute value for scaling decisions
  const absValue = Math.abs(value);

  const valueToFormat =
    scale && absValue > 1000000
      ? absValue / 1000000
      : scale && absValue > 1000
      ? absValue / 1000
      : absValue;

  const formattedString = new Intl.NumberFormat("en-US", {
    style: "currency",
    currency: "USD",
    minimumFractionDigits: round ? 0 : 2,
    maximumFractionDigits: round ? (absValue > 1000000 ? 1 : 0) : 2,
  }).format(valueToFormat);

  // Preserve the sign in the output
  const signPrefix = sign === -1 ? "-" : "";

  return scale && absValue > 1000000
    ? `${signPrefix}${formattedString}M`
    : scale && absValue > 1000
    ? `${signPrefix}${formattedString}K`
    : `${signPrefix}${formattedString}`;
}

/**
 * Removes database metadata properties from an object.
 *
 * @param obj - The object from which to remove the metadata properties.
 * @returns A new object without the database metadata properties.
 */
export function stripDbMetadata(obj: Object) {
  return Object.fromEntries(
    Object.entries(obj).filter(
      ([key]) =>
        ![
          "$collectionId",
          "$databaseId",
          "$permissions",
          "$createdAt",
          "$updatedAt",
        ].includes(key)
    )
  );
}

/**
 * Removes common null keys from an array of objects.
 * If any key is not null in any object, it is not removed.
 *
 * @param data - The array of objects to remove common null keys from.
 * @returns The array of objects with common null keys removed.
 */
export function removeCommonNulls(data: any[]): any[] {
  if (data.length === 0) return data;

  // Step 1: Identify keys that are null in all objects
  const commonNullKeys = new Set<string>();

  // Initialize commonNullKeys with keys from the first object
  Object.keys(data[0]).forEach((key) => {
    if (data[0][key] === null) {
      commonNullKeys.add(key);
    }
  });

  // Check other objects
  for (let i = 1; i < data.length; i++) {
    for (const key of commonNullKeys) {
      if (data[i][key] !== null) {
        commonNullKeys.delete(key);
      }
    }
  }

  // Step 2: Remove common null keys from each object
  return data.map((obj) => {
    const newObj = { ...obj };
    for (const key of commonNullKeys) {
      delete newObj[key];
    }
    return newObj;
  });
}

/**
 * Calculates the monthly net worth totals based on the provided data.
 *
 * @param data - The collection of net worth assets.
 * @returns An array of objects containing the month and the total net worth for that month.
 */
export function getMonthlyNetWorthTotals(data: NetWorthAssetsCollection[]) {
  const monthlyTotals: { month: string; total: number }[] = [];

  data.forEach((item) => {
    const month = getMonth(item.date);
    let total = 0;

    Object.values(item).forEach((value) => {
      if (typeof value === "number") total += value;
    });

    monthlyTotals.push({ month, total });
  });

  return monthlyTotals;
}

/**
 * Returns the error message from an error object or Appwrite response object.
 *
 * @param error - The error object to extract the message from.
 * @returns The error message as a APIResponse object.
 */
export function handleError(error: any): APIResponse {
  if ((error as Error).message) {
    return {
      error: (error as Error).message,
    };
  } else {
    return {
      error: JSON.stringify((error as any)?.response?.message),
    };
  }
}

/**
 * Fetches a logo from the given URL and returns it as a base64 encoded string.
 *
 * @param url - The URL of the logo to fetch.
 * @returns A promise that resolves to the base64 encoded string of the logo if the fetch is successful, or null if the fetch fails.
 */
export async function getLogoUsingURL(url: string | null | undefined) {
  if (!url) return null;

  const domain = new URL(url).hostname;

  const response = await fetch(
    `https://icons.duckduckgo.com/ip3/${domain}.ico`
  );

  if (response.ok) {
    const logo = await response.arrayBuffer();
    return Buffer.from(logo).toString("base64");
  }

  return null;
}

/**
 * Returns the ordinal suffix for a given day of the month.
 *
 * @param day - The day of the month (1-31).
 * @returns The ordinal suffix ("st", "nd", "rd", "th") for the given day.
 */
export function getOrdinalSuffix(day: number): string {
  if (day >= 11 && day <= 13) return "th";

  switch (day % 10) {
    case 1:
      return "st";
    case 2:
      return "nd";
    case 3:
      return "rd";
    default:
      return "th";
  }
}

/**
 * Extracts unique years from an array of documents with date properties.
 * Returns years sorted in descending order (newest first).
 *
 * @param documents - Array of documents containing date properties.
 * @returns Array of year strings sorted in descending order.
 */
export function extractYearsFromDocuments(
  documents: Models.Document[]
): string[] {
  const years = new Set<string>();

  documents.forEach((doc) => {
    const date = new Date(doc.date);
    years.add(date.getFullYear().toString());
  });

  return Array.from(years).sort((a, b) => parseInt(b) - parseInt(a));
}

/**
 * Parses and stringifies an object to remove any circular references.
 *
 * @param value - The object to parse and stringify.
 * @returns The parsed and stringified object.
 */
export const parseStringify = (value: any) => JSON.parse(JSON.stringify(value));
