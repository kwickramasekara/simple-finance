import { type ClassValue, clsx } from "clsx";
import { twMerge } from "tailwind-merge";

/**
 * Returns a combined class name string from the provided class values.
 * Generated by ShadCN
 *
 * @param inputs - The class values to be combined.
 * @returns The combined class name string.
 */
export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

/**
 * Returns the month name for a given date.
 * @param date - The date in string format.
 * @param short - Optional parameter to return the short form of the month name.
 * @returns The month name as a string.
 */
export function getMonth(date: string, short = false): string {
  const month = new Date(date).toLocaleString("default", { month: "long" });

  return short ? month.slice(0, 3) : month;
}

/**
 * Formats a number as a currency string.
 *
 * @param value - The number to format as currency.
 * @param round - Whether to round the number or not. Default is true.
 * @param scale - Whether to scale the number for thousands and millions. Default is false.
 * @returns The formatted currency string.
 */
export function formatCurrency(
  value: number,
  round = true,
  scale = false
): string {
  // Determine the sign of the value (-1 for negative, 1 for positive, 0 for zero)
  const sign = Math.sign(value);

  // Use the absolute value for scaling decisions
  const absValue = Math.abs(value);

  const valueToFormat =
    scale && absValue > 1000000
      ? absValue / 1000000
      : scale && absValue > 1000
      ? absValue / 1000
      : absValue;

  const formattedString = new Intl.NumberFormat("en-US", {
    style: "currency",
    currency: "USD",
    minimumFractionDigits: round ? 0 : 2,
    maximumFractionDigits: round ? (absValue > 1000000 ? 1 : 0) : 2,
  }).format(valueToFormat);

  // Preserve the sign in the output
  const signPrefix = sign === -1 ? "-" : "";

  return scale && absValue > 1000000
    ? `${signPrefix}${formattedString}M`
    : scale && absValue > 1000
    ? `${signPrefix}${formattedString}K`
    : `${signPrefix}${formattedString}`;
}

/**
 * Removes database metadata properties from an object.
 *
 * @param obj - The object from which to remove the metadata properties.
 * @returns A new object without the database metadata properties.
 */
export function stripDbMetadata(obj: Object) {
  return Object.fromEntries(
    Object.entries(obj).filter(
      ([key]) =>
        ![
          "$collectionId",
          "$databaseId",
          "$permissions",
          "$createdAt",
          "$updatedAt",
        ].includes(key)
    )
  );
}

/**
 * Removes common null keys from an array of objects.
 * If any key is not null in any object, it is not removed.
 *
 * @param data - The array of objects to remove common null keys from.
 * @returns The array of objects with common null keys removed.
 */
export function removeCommonNulls(data: any[]): any[] {
  if (data.length === 0) return data;

  // Step 1: Identify keys that are null in all objects
  const commonNullKeys = new Set<string>();

  // Initialize commonNullKeys with keys from the first object
  Object.keys(data[0]).forEach((key) => {
    if (data[0][key] === null) {
      commonNullKeys.add(key);
    }
  });

  // Check other objects
  for (let i = 1; i < data.length; i++) {
    for (const key of commonNullKeys) {
      if (data[i][key] !== null) {
        commonNullKeys.delete(key);
      }
    }
  }

  // Step 2: Remove common null keys from each object
  return data.map((obj) => {
    const newObj = { ...obj };
    for (const key of commonNullKeys) {
      delete newObj[key];
    }
    return newObj;
  });
}

/**
 * Calculates the monthly net worth totals based on the provided data.
 *
 * @param data - The collection of net worth assets.
 * @returns An array of objects containing the month and the total net worth for that month.
 */
export function getMonthlyNetWorthTotals(data: NetWorthAssetsCollection[]) {
  const monthlyTotals: { month: string; total: number }[] = [];

  data.forEach((item) => {
    const month = getMonth(item.date);
    let total = 0;

    Object.values(item).forEach((value) => {
      if (typeof value === "number") total += value;
    });

    monthlyTotals.push({ month, total });
  });

  return monthlyTotals;
}
